题目描述：
给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：

区间中的最小数 乘以 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列  [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值:

[6] = 6 * 6 = 36;

[2] = 2 * 2 = 4;

[1] = 1 * 1 = 1;

[6,2] = 2 * 8 = 16;

[2,1] = 1 * 3 = 3;

[6, 2, 1] = 1 * 9 = 9;

从上述计算可见选定区间 [6] ，计算值为 36， 则程序输出为 36。

区间内的所有数字都在[0, 100]的范围内;

输入描述:

第一行输入数组序列长度n，第二行输入数组序列。
对于 50%的数据,  1 <= n <= 10000;
对于 100%的数据, 1 <= n <= 500000;

 

输出描述:

输出数组经过计算后的最大值。

 

输入例子1:
3
6 2 1

输出例子1:

36

/*
思路1 dfs求出所有子区间，然后求出最小值，子区间和，再更新全局最大值。果断超时。
思路2 对数组中的每一个数，向左向右遍历找出第一个小于它的数，边遍历边求和，得到的区间就是以当前数为最小值的区间。
思路3 使用单调栈。栈内元素单调递增，当弹出一个元素后，栈顶元素一定是左边第一个小于当前元素的数，而使它弹出的元素
一定是右边第一个小于它的数，此时组成的子区间正好符合要去，弹出的元素就是区间内的最小元素。
*/

//思路2
int func(vector<int>&v){
  int res=0;
  for(int i=0;i<v.size();i++){
    int sum = v[i],j=i+1;
    while(j<v.size() && v[j]>v[i]){
      sum+=v[j];
      j++;
    }
    j=i-1;
    while(j>=0 && v[j]>v[i]){
      sum+=v[j];
      j--;
    }
    res = max(res,v[i]*sum);
  }
  return res;
}

//思路3
int func(vector<int>&v) {
	int n = v.size(), res = 0;
	vector<int>sum(n + 1, 0);
	for (int i = 1; i <= n; i++)sum[i] = v[i - 1] + sum[i - 1];
	stack<int>s;
	for (int i = 0; i < n; i++) {
		while (!s.empty() && v[i] < v[s.top()]) {
			int right = i;
			int idx = s.top();
			s.pop();
			int left = s.size() == 0 ? 0: s.top()+1;
			res = max(res, v[idx] * (sum[right] - sum[left]));
		}
		s.push(i);
	}
	return res;
}
